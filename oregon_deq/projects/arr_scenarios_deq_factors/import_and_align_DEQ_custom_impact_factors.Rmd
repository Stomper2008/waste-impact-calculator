---
title: "Importing and aligning DEQ's custom impact factors"
output: html_notebook
---

by Martin Brown
Martin.Brown@state.or.us
+1.503.229.5502

This R Markdown notebook documents my work to import DEQ's in-house impact factors for the Waste Impact Calculator, and align them with the materials and disposition names found in DEQ's solid waste data.

Some basic orientation on the Waste Impact Calculator (formerly IMFO) model can be found in the old IMFO project profile on DEQ's local network drive at \\deqhq1\swrshare\!PROGRAMS-SOLID-WASTE-(PSW)\LCA\Projects\IMFO\Phase 3\project planning and progress\IMFOprojectProfile20180214.pdf .

## Introduction

For the WIC model to calculate impacts correctly, it needs to draw on two data files which are unified in terms of certain key variables.

One data file is about materials in the waste stream.  It should have one record for each combination of:

* Wasteshed (or county, city, company, or other geographic i.d.)
* Year (or other temporal id)
* Material
* [Life Cycle Stage]
* [Umbrella Disposition]
* Disposition (this means end of life disposition, such as landfilling or recycling)

Items in [square brackets] are extra key variables that are somewhat redundant but will be useful later on.  (Explain in more detail later.)

For each of these records, waste stream data file will have two actual data:

* Tons (of the material in question)
* End of life transport miles

It may make more sense to do it this way, so that the EOL transport is just another LC stage. eg....
Wasteshed Material  LCstage UmbDisp   Disp      Tons  EOLdistM
Benton    Glass     EOL     Disposal  Landfill  5     0
Benton    Glass     EOLt    Disposal  Landfill  5     20
Benton    Glass     EOL     Recovery  Recycling 10    0
Benton    Glass     EOLt    Recovery  Recycling 10    100

The other data file is about impact factors.  It should have one record for each combination of:

* Material
* [Life Cycle Stage]
* [Umbrella Disposition]
* Disposition 
* Impact Category (e.g. global warming potential, water use, etc.)

There must be one such record for each combination of Material, Life Cycle Stage, Umbrella Disposition, and Disposition found in the waste stream data file.  Each impact factor record must include, after the impact category name, the:

* impact factor value (in impact units per short ton)
* units of the impact factor (as a text string)

The impact factor file must contain additional impact factors representing additional Life Cycle Stages not necessarily found in the waste stream data file.

* impact factors for the Production of each material (one record per material and impact category)
* impact factors for the end-of-life transportation of each material (one record per material and impact category), convertible to a per-mile factor (that means rates must be per mile or must include a presumed mileage)

## Goal of this markdown file

The goal of the present markdown file is to import the impact factors that Peter Canepa has generated, and check them to assure that their key values are perfectly aligned with the key values in the waste stream file (imported in a separate markdown document).  All spellings must match, possibilities must be accounted for, and so on.

## Setting up the workspace

Here i'm going to load in packages I use.
Normally I also use "checkpoint" to try to control package versions, but it has been screwy lately, so it is blanked out for now.
```{r}
# doing a bit of version control, setting packages to beginning of 2019
library(checkpoint)
# checkpoint("2018-09-30", verbose = T)

# getting packages I might need
library(tidyverse)
library(readxl)
library(openxlsx)
# library(RODBC)
library(scales)
library(knitr)
library(rmarkdown)
# library(sjPlot)
```

## Importing the impact factors

Here I'm going to import Peter Canepa's impact factors and filter them down a bit.  These factors may need a bit of editing later on to match the materials that come out of Oregons' solid waste data, so this import isn't the end of the story.  

Fortunately I have an old script whose purpose was to process this data.  Let's see if it still works!

```{r}
# This R syntax imports impact factors created 
# by Peter Canepa for the IMFO project.  Impact factors relate mass
# of defined materials, for defined processes, to environmental 
# impacts such as water use and greenhouse gas emissions.
# For example, there are several impact factors for the material
# called "food": a production impact factor, a landfilling impact
# factor, a composting impact factor, etc.

# input: XLSX file produced by Peter Canepa, and exported from GABI
# output: an R data frame with the impact factors in "tidy" format

# here is the input file spec
impactFactorsSourceFilespec <- 
   "../../source_data/or_deq_impact_factors_for_wic.xlsx"

# getting the impact factors themselves, without column names
impactFactorsRaw <- read_xlsx(
   path=impactFactorsSourceFilespec, 
   range="g10:de63",
   col_names = FALSE,
   trim_ws = TRUE
   )
# getting the column names, removing weird tags from them, and 
# doing some other fixes
impactFactorsColumnNames <- as.character(
   read_xlsx(
      path=impactFactorsSourceFilespec,
      range="g9:de9",
      col_names=FALSE,
      col_types=c("text")
      )
   )
# removing a weird character string (" <") from a few of the 
# prospective column names
impactFactorsColumnNames2 <-
   str_sub(
      impactFactorsColumnNames,
      start=1,
      end=ifelse(
         str_locate(impactFactorsColumnNames," <")[,1] > 1,
         str_locate(impactFactorsColumnNames," <")[,1] -1,
         NA
         )
      )
impactFactorsColumnNames <-
   ifelse(
      is.na(impactFactorsColumnNames2),
      impactFactorsColumnNames,
      impactFactorsColumnNames2
      )
rm(impactFactorsColumnNames2)

# providing names to two columns which don't have them.
# the first one is the "impact category", and the 
# second one was something internal to Peter Canepa's
# process
impactFactorsColumnNames[1] <- "impactCategoryRaw" 
impactFactorsColumnNames[2] <- "peterCcheckVariable" 

# adding the column names to the impact factors
if(
   length(impactFactorsColumnNames)==ncol(impactFactorsRaw)
   ) {
   names(impactFactorsRaw) <- impactFactorsColumnNames
   }
# printing out what we've got so far
str(impactFactorsRaw)
print(impactFactorsRaw)
```
```{r}
# now let's get rid of some of the junk in that file
# of impact factors.
# getting rid of rows with all zero impacts
impactFactorsRawFiltered <- filter(
   impactFactorsRaw,
   impactFactorsRaw[,2]!=0 & impactFactorsRaw[,3]!=0 & impactFactorsRaw[,4]!=0
   )
str(impactFactorsRawFiltered)
```
```{r}
# now let's flip the columns so they are rows.
# we want to create a "tidy" file -- where each
# row is one observation.
impactFactorsRawFlipped <- gather(
   impactFactorsRawFiltered,
   key="material_LCstage_disposition",
   value="impactFactor",
   -impactCategoryRaw
   ) %>%
   # filtering out peter C's private impact category
   filter(material_LCstage_disposition!="peterCcheckVariable")

# printing out what I've got
str(impactFactorsRawFlipped)
```
```{r}
# now I've got these really long fields that need to be parsed into 
# separate fields.

# impactCategoryRaw is actually a concatenation of impactCategory, 
# impactUnits, and corporateSource (for example "TRACI, Global warming 
# potential [MTCO2E]") actually means an impactCategory of 
# "Global warming potential" in impactUnits of "MTCO2E" according to the 
# "TRACI" Corporate Source.

# parsing...
impactFactorsRawFlippedParsed <- mutate(
   impactFactorsRawFlipped,
   corporateSource = str_sub(
      impactCategoryRaw,
      start=0,
      end=str_locate(impactCategoryRaw,",")[,1]-1
      ),
   impactCategory = str_sub(
      impactCategoryRaw,
      start=str_locate(
         impactCategoryRaw,
         ", "
         )[,2]+1,
      end=str_locate(
         impactCategoryRaw,
         " \\["
         )[,1]-1
      ),
   impactCategory=ifelse(
      !is.na(impactCategory),
      impactCategory,
      str_sub(
         impactCategoryRaw,
         start=1,
         end=str_locate(
            impactCategoryRaw,
            "\\["
            )[,1]-2
         )
      ),
   impactUnits= str_sub(
      impactCategoryRaw,
      start=str_locate(
         impactCategoryRaw,
         "\\["
         )[,1]+1,
      end=str_locate(
         impactCategoryRaw,
         "\\]"
         )[,1]-1
      )
   )
str(impactFactorsRawFlippedParsed)

# now similarly field material_LCstage_disposition is a concatenation
# of those fields
# parsing...
impactFactorsRawFlippedParsed2 <- mutate(
   impactFactorsRawFlippedParsed,
   material=str_sub(
      material_LCstage_disposition,
      start=1,
      end=str_locate(material_LCstage_disposition,"_")[,1]-1
      ),
   theRestOfIt=str_sub(
      material_LCstage_disposition,
      start=str_locate(material_LCstage_disposition,"_")[,1]+1,
      end=str_length(material_LCstage_disposition)
      ),
   LCstage=str_sub(
      theRestOfIt,
      start=1,
      end=str_locate(theRestOfIt,"_")[,1]-1
      ),
   disposition=str_sub(
      theRestOfIt,
      start=str_locate(theRestOfIt,"_")[,1]+1,
      end=str_length(theRestOfIt)
      )
   ) %>%
   select(-theRestOfIt)

str(impactFactorsRawFlippedParsed2)

# and let's add a way to identify the set of impact factors.
# this is not strictly necessary right now, but in the long term we'll 
# be doing lots of analyses with various impact factors, and knowing 
# the exact data and version of Gabi's output could 
# be useful.
impactFactorIDinfo <-   
   read_xlsx(
      path=impactFactorsSourceFilespec,
      range="b3:e3",
      col_names=FALSE,
      col_types=c("text","skip","skip","date")
      )
names(impactFactorIDinfo) <- c("impactFactorSource","impactFactorVersionDate")
impactFactorID <- paste(
   impactFactorIDinfo[1,]$impactFactorSource,
   "_",
   as.character(impactFactorIDinfo[1,]$impactFactorVersionDate),
   sep=""
   )
impactFactorsRawFlippedParsed3 <- mutate(
   impactFactorsRawFlippedParsed2,
   impactFactorID=impactFactorID
   )

# and let's get rid of columns I don't want
impactFactorsAll <- select(
   impactFactorsRawFlippedParsed3,
   material,LCstage,disposition,impactCategory,impactUnits,impactFactor,
     corporateSource,impactFactorID
   )
str(impactFactorsAll)

# correcting a typo in the material names
impactFactorsAll <- mutate(
  impactFactorsAll,
  material = ifelse(material == "Woood", "Wood", material)
  ) %>%
  unique() 

# impactFactorsAll is the tidy data frame with the usable factors.

# removing unneeded objects
rm(impactFactorIDinfo,impactFactorsRaw,impactFactorsRawFiltered,
   impactFactorsRawFlipped,impactFactorsRawFlippedParsed,
   impactFactorsRawFlippedParsed2,impactFactorsRawFlippedParsed3,
   impactFactorID,impactFactorsColumnNames,impactFactorsSourceFilespec)

# Because this is such a complicated import process, I am going to write 
# a spreadsheet file to check against Peter Canepa's original.
write.csv(
   impactFactorsAll,
   "intermediate_output/deq_impact_factors_exported_for_checking.csv",
   row.names = FALSE
   )
```

That looked pretty good. I checked some entries at random between my import and Peter C's source and they were all correct.  There was one little problems with the parser that separated the impact category from the corporate source, but given that I'm not using all impact categories anyway that may not make a difference. 

Let's filter that down to the five or six impact categories I want, and shorten the impact factor names to something usable.

```{r}
# winnowing impact factors down to a shorter list
impactFactorsSelected <-
  filter(
    impactFactorsAll,
    impactCategory   == "Blue water consumption" |
      impactCategory == "Eutrophication" |
      impactCategory == "Global Warming Air, incl biogenic carbon, incl LUC, no norm/weight" |
      impactCategory == "Human toxicity, cancer (recommended)" |
      impactCategory == "Primary energy demand from ren. and non ren. resources (net cal. value)" |
      impactCategory == "Smog Air"
      )  %>%
  # making shorter names
  mutate(
    impactCategory   = case_when(
      impactCategory == "Blue water consumption" ~ "Water consumption",
      impactCategory == "Eutrophication" ~ "Eutrophication",
      impactCategory == "Global Warming Air, incl biogenic carbon, incl LUC, no norm/weight" ~ "Global warming",
      impactCategory == "Human toxicity, cancer (recommended)" ~ "Human toxicity",
      impactCategory == "Primary energy demand from ren. and non ren. resources (net cal. value)" ~ "Energy demand",
      impactCategory == "Smog Air" ~ "Smog"
      )
    ) %>%
  # eliminating some technical variables not necessary for the interactive IMFO
  # app
  select(-corporateSource,-impactFactorID)
# the result should looks something like this:
# > print(impactFactorsSelected)
# # A tibble: 198 x 6
#    material LCstage   disposition           impactCategory  impactUnits impactFactor
#    <chr>    <chr>     <chr>                 <chr>           <chr>              <dbl>
#  1 Aluminum endOfLife incinerationNoER      Energy demand   MJ               2.48e+3
#  2 Aluminum endOfLife incinerationNoER      Global warming  kg CO2 eq.       1.49e+2
#  3 Aluminum endOfLife incinerationNoER      Eutrophication  kg N eq.         3.06e-2
#  4 Aluminum endOfLife incinerationNoER      Human toxicity  CTUh             1.51e-7

```

This is good, but it's a little complex for use in most applications of the Waste Impact Calculator.  This set of factors has transport factors separated out for both production and end of life.  We don't need separate production and production transport factors.  Moreover the names for the dispositions are really long.  Finally the LC stages need to be split a little bit, into production, EOL, and EOL transport.  

To do all this I'm going to have to split the impact factor file up and reassemble it after tweaking appropriately.

```{r}
# isolating production impact factors
ifProdJunk1 <- filter(
  impactFactorsSelected,
  LCstage == "production"
  )
# summing those up (combining production & production transport)
ifProdJunk2 <- summarise(
  group_by(ifProdJunk1, material, LCstage, impactCategory, impactUnits),
  impactFactor=sum(impactFactor, na.rm=T)
  ) %>%
  ungroup() %>%
  mutate(disposition="production")
# so ifProdJunk2 has the production impact factors

# isolating end-of-life impact factors
ifEOLJunk1 <- filter(
  impactFactorsSelected,
  LCstage == "endOfLife"
  )

# cleaning up dispositions and LCstages
# splitting the disposition field into first part (the EOL disposition)
# and the second part (the EOL transport)
ifEOLJunk2 <- mutate(
  ifEOLJunk1,
  hello=ifelse(
    regexpr("_",disposition)>0,
    regexpr("_",disposition),
    nchar(disposition)+1
    ),
  disp1=str_sub(disposition, start=1, end=hello-1),
  disp2=str_sub(disposition, start=hello+1, end=nchar(disposition))
  ) %>%
  # now I can make the EOL transport an LC stage
  mutate(
    LCstage=ifelse(
      disp2 == "transport",
      "endOfLifeTransport",
      LCstage
      )
    )
# now I can remove disp2, disposition and the temp variable hello
# and rename disp2 as disposition
ifEOLJunk3 <- select(
  ifEOLJunk2,
  -disp2, -disposition, -hello
  ) %>%
  rename(disposition = disp1)

# now I can recombine the ifProdJunk2 & ifEOLJunk3
ifJunk1 <- bind_rows(
  ifProdJunk2,
  ifEOLJunk3
  )

# now it should look something like this..
# > sample_n(ifJunk1,5)
# # A tibble: 5 x 6
#   material  LCstage          impactCategory impactUnits impactFactor disposition    
#   <chr>     <chr>            <chr>          <chr>              <dbl> <chr>          
# 1 FoodWaste endOfLifeTransp~ Global warming kg CO2 eq.          23.0 incinerationNo~
# 2 FoodWaste production       Smog           kg O3 eq.           85.9 production     
# 3 Aluminum  endOfLife        Smog           kg O3 eq.         -115.  recyclingGener~
# 4 Aluminum  endOfLife        Energy demand  MJ              -30251.  recyclingGener~
# 5 Glass     endOfLifeTransp~ Eutrophication kg N eq.             0   reuse       

```

Currently this list is still pretty long.
I'm going to cut some dispositions as unrealistic.
I'm going to rename some dispositions for clarity.
And I'm going to set the implied mileage of the end-of-life impact factors.

```{r}
# cutting some uncommon dispositions
ifJunk2 <- mutate(
  ifJunk1,
  cutFlag = case_when(
    disposition == "incinerationNoER" ~ TRUE,
    disposition == "recyclingFiberglass" ~ TRUE,
    disposition == "reuse" ~ TRUE
    )
  ) %>%
  filter(is.na(cutFlag)) %>%
  select(-cutFlag) %>%
  # renaming some awkward dispositions
  mutate(
    disposition = case_when(
      disposition == "recyclingGeneric" ~ "recycling",
      disposition == "recyclingAggregate" ~ "useAsAggregate",
      disposition == "recyclingToAggregate" ~ "useAsAggregate",
      disposition == "recyclingToContainer" ~ "recycling",
      disposition == "incinerationER" ~ "combustion",
      TRUE ~ disposition
      )
    ) %>%
  # adding implied mileage for EOL transport impact factors
  mutate(
    impliedMiles = case_when(
      LCstage == "endOfLifeTransport" & disposition == "landfilling" ~ 180,
      LCstage == "endOfLifeTransport" & disposition == "recycling" ~ 180,
      LCstage == "endOfLifeTransport" & disposition == "composting" ~ 180,
      LCstage == "endOfLifeTransport" & disposition == "useAsAggregate" ~ 20,
      LCstage == "endOfLifeTransport" & disposition == "anaerobicDigestion" ~ 180,
      LCstage == "endOfLifeTransport" & disposition == "combustion" ~ 180,
      TRUE ~ 180
      )
    ) %>%
  # reordering the variables
  select(material, LCstage, disposition, impactCategory,
         impactUnits, impactFactor, impliedMiles)

# saving that as the dedicated impact factor file
impactFactorsIMFOapp <- ifJunk2

# sorting it
impactFactorsIMFOapp <- arrange(
  impactFactorsIMFOapp, material, impactCategory, LCstage, disposition
  )
```

however, peter canepa says not to use a few of those, because he's still working on them.

```{r}
impactFactorsIMFOapp <-
  filter(impactFactorsIMFOapp, material != "Wood" & material != "Electronics")
```

```{r}
# let's rename it
impact_factors_deq <- impactFactorsIMFOapp
```


If it all looks good, I can delete the temporary objects.
```{r}
# deleting work objects
rm(ifEOLJunk1, ifEOLJunk2, ifEOLJunk3, ifJunk1, ifJunk2, ifProdJunk1,
   ifProdJunk2, impactFactorsAll, impactFactorsSelected,
   impactFactorsIMFOapp)
```

So, as a test, I checked the "Glass" impact factors in impact_factors_deq against Peter C's original spreadsheet and everything checked out.  The important thing to remember is that the end-of-life transport factors include an implied mileage... i.e. at this point they are NOT in per-mile terms.

## standardizing the names of materials and dispositions against deq solid waste data

To do this truly properly, I need to:
* create a zero file that contains all the possibilities of material, LCstage, and disposition in Peter C's impact factors, but zero tons.
* replicate that zero file across all the combos of year and wasteshed in the solid waste file.
* convert all the material names and disposition names in the solid waste file to the material and disposition names Peter Canepa uses.
* fill the zero file in.

```{r}
# here is the mass profile
baseline_mass_profile <- 
  readRDS("../arr_scenarios_warm_factors/intermediate_output/baseline_mass_profile.RData")
# here are all the combinations of year and wasteshed
waste_stream_years_and_wastesheds <-
  select(baseline_mass_profile, year, wasteshed) %>%
  unique()
# here are all the combinations of material, LCstage, and disposition
# in the impact factor file
impact_factor_materials_LCstages_and_dispositions <-
  impact_factors_deq %>%
  select(material, LCstage, disposition) %>%
  unique()
# here is the zero file (all the combinations of year, wasteshed,
# material, LCstage, and disposition), but with no tons attached
zero_file <-
  full_join(
    mutate(waste_stream_years_and_wastesheds, dummy=1),
    mutate(impact_factor_materials_LCstages_and_dispositions, dummy=1),
    by="dummy"
  ) %>%
  select(-dummy)
# now correcting the MRS and WARM based names in the solid waste data
# to Canepa-standard names
# loading in a crosswalk table
deq_x_mrs_x_warm <- 
  read_excel("../../source_data/deq_x_mrs_x_warm.xlsx")
# joining the crosswalk together
baseline_mass_profile_corrected <-
  full_join(
    rename(
      baseline_mass_profile,
      mrs_material=material,
      mrs_disposition=disposition
    ) %>% 
    mutate(inMRS=TRUE),
    mutate(
      deq_x_mrs_x_warm,
      inImpactFactors=TRUE
    ),
    by=c("mrs_material", "mrs_disposition")
  )
# separating four mass-related files for later examination
# materials and dispositions that match up well
baseline_masses_ok <- 
  filter(
    baseline_mass_profile_corrected,
    inMRS==TRUE & inImpactFactors==TRUE
  ) %>%
  select(
    year, wasteshed, material, disposition, umbDisp, tons
  )
# materials and dispositions that are only in the waste stream file
baseline_masses_unmatched <-
  filter(
    baseline_mass_profile_corrected,
    inMRS==TRUE & is.na(inImpactFactors)
  )
# those same unmatched materials and dispositions, but 
# as unique combos
baseline_unmatched_materials_and_dispositions <-
  baseline_masses_unmatched %>%
  select(mrs_material, mrs_disposition, umbDisp) %>%
  unique() %>%
  arrange(mrs_material, mrs_disposition)
# materials and dispositions that are only in the impact factor file
baseline_masses_unrepresented <-
  filter(
    baseline_mass_profile_corrected,
    is.na(inMRS) & inImpactFactors==TRUE
  )
# combining the zero file and the matched materials and dispositions
baseline_mass_profile_better <-
  full_join(
    zero_file,
    baseline_masses_ok,
    by=c("year", "wasteshed", "material", "disposition")
  ) %>%
  mutate(tons=ifelse(is.na(tons),0,tons)) # fills in missing zeros
```

Eventually, the lists of unmatched and unrepresented masses should dwindle to zero.

Now, in concept, every tonnage in baseline_mass_profile_better should be matched with an impact factor from impact_factors_deq.  Let's try it!

```{r}
myTest <-
  left_join(
    baseline_mass_profile_better,
    impact_factors_deq,
    by=c("material", "LCstage", "disposition")
  ) %>%
  arrange(impactCategory, year, wasteshed, material, LCstage, disposition)
myTest2 <-
  filter(myTest, is.na(impactFactor) | is.na(impliedMiles))
```

Looks like myTest2 has zero records in it.

So to clean up, I need to save both the impact factors and the improved baseline data for later use.  Then erase the rest of the objects.

```{r}
# saving impact factors
saveRDS(
  impact_factors_deq, 
  "intermediate_output/impact_factors_deq.RData"
  )
write.csv(
  impact_factors_deq, 
  "intermediate_output/impact_factors_deq.csv",
  row.names = F
  )
# savings baseline data that has been matched to impact factors
saveRDS(
  baseline_mass_profile_better,
  "intermediate_output/baseline_mass_profile_deq.RData"
)
write.csv(
  baseline_mass_profile_better,
  "intermediate_output/baseline_mass_profile_deq.csv",
  row.names = F
)
```

Erasing all objects
```{r}
rm(list=ls())
```