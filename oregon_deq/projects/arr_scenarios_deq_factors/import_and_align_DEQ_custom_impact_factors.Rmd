---
title: "Importing and aligning DEQ's custom impact factors"
output: html_notebook
---

by Martin Brown
Martin.Brown@state.or.us
+1.503.229.5502

This R Markdown notebook documents my work to import DEQ's in-house impact factors for the Waste Impact Calculator, and align them with the materials and disposition names found in DEQ's solid waste data.

Some basic orientation on the Waste Impact Calculator (formerly IMFO) model can be found in the old IMFO project profile on DEQ's local network drive at \\deqhq1\swrshare\!PROGRAMS-SOLID-WASTE-(PSW)\LCA\Projects\IMFO\Phase 3\project planning and progress\IMFOprojectProfile20180214.pdf .

This code has been around a while in various forms; the emphasis in my current work on it is to make the baseline mass profiles end-of-life only, but also reflective of all the conceivable end-of-life options.

## Introduction

For the WIC model to calculate impacts correctly, it needs to draw on two data files which are unified in terms of certain key variables.

One data file is about materials in the waste stream.  It should have one record for each combination of:

* Wasteshed (or county, city, company, or other geographic i.d.)
* Year (or other temporal id)
* Material
* [Life Cycle Stage]
* [Umbrella Disposition]
* Disposition (this means end of life disposition, such as landfilling or recycling)

Items in [square brackets] are extra key variables that are somewhat redundant but will be useful later on.  (Explain in more detail later.)

For each of these records, waste stream data file will have two actual data:

* Tons (of the material in question)
* End of life transport miles

It may make more sense to do it this way, so that the EOL transport is just another LC stage. eg....
Wasteshed Material  LCstage UmbDisp   Disp      Tons  EOLdistM
Benton    Glass     EOL     Disposal  Landfill  5     0
Benton    Glass     EOLt    Disposal  Landfill  5     20
Benton    Glass     EOL     Recovery  Recycling 10    0
Benton    Glass     EOLt    Recovery  Recycling 10    100

The other data file is about impact factors.  It should have one record for each combination of:

* Material
* [Life Cycle Stage]
* [Umbrella Disposition]
* Disposition 
* Impact Category (e.g. global warming potential, water use, etc.)

There must be one such record for each combination of Material, Life Cycle Stage, Umbrella Disposition, and Disposition found in the waste stream data file.  Each impact factor record must include, after the impact category name, the:

* impact factor value (in impact units per short ton)
* units of the impact factor (as a text string)

The impact factor file must contain additional impact factors representing additional Life Cycle Stages not necessarily found in the waste stream data file.

* impact factors for the Production of each material (one record per material and impact category)
* impact factors for the end-of-life transportation of each material (one record per material and impact category), convertible to a per-mile factor (that means rates must be per mile or must include a presumed mileage)

## Goal of this markdown file

The goal of the present markdown file is to import the impact factors that Peter Canepa has generated, and check them to assure that their key values are perfectly aligned with the key values in the waste stream file (imported in a separate markdown document).  All spellings must match, possibilities must be accounted for, and so on.

## Setting up the workspace

Here i'm going to load in packages I use.
Normally I also use "checkpoint" to try to control package versions, but it has been screwy lately, so it is blanked out for now.
```{r}
# doing a bit of version control, setting packages to beginning of 2019
# library(checkpoint)
# checkpoint("2018-09-30", verbose = T)

# getting packages I might need
library(tidyverse)
library(readxl)
library(openxlsx)
library(RODBC)
library(scales)
library(knitr)
library(rmarkdown)
# library(sjPlot)
```

## Importing the impact factors

Here I'm going to import Peter Canepa's impact factors and filter them down a bit.  These factors may need a bit of editing later on to match the materials that come out of Oregons' solid waste data, so this import isn't the end of the story.  

Fortunately I have an old script whose purpose was to process this data.  Let's see if it still works!

```{r}
# This R syntax imports impact factors created 
# by Peter Canepa for the IMFO project.  Impact factors relate mass
# of defined materials, for defined processes, to environmental 
# impacts such as water use and greenhouse gas emissions.
# For example, there are several impact factors for the material
# called "food": a production impact factor, a landfilling impact
# factor, a composting impact factor, etc.

# input: XLSX file produced by Peter Canepa, and exported from GABI
# output: an R data frame with the impact factors in "tidy" format

# here is the input file spec
impactFactorsSourceFilespec <- 
   "../../source_data/or_deq_impact_factors_for_wic.xlsx"

# getting the impact factors themselves, without column names
impactFactorsRaw <- read_xlsx(
   path=impactFactorsSourceFilespec, 
   range="g10:de63",
   col_names = FALSE,
   trim_ws = TRUE
   )
# getting the column names, removing weird tags from them, and 
# doing some other fixes
impactFactorsColumnNames <- as.character(
   read_xlsx(
      path=impactFactorsSourceFilespec,
      range="g9:de9",
      col_names=FALSE,
      col_types=c("text")
      )
   )
# removing a weird character string (" <") from a few of the 
# prospective column names
impactFactorsColumnNames2 <-
   str_sub(
      impactFactorsColumnNames,
      start=1,
      end=ifelse(
         str_locate(impactFactorsColumnNames," <")[,1] > 1,
         str_locate(impactFactorsColumnNames," <")[,1] -1,
         NA
         )
      )
impactFactorsColumnNames <-
   ifelse(
      is.na(impactFactorsColumnNames2),
      impactFactorsColumnNames,
      impactFactorsColumnNames2
      )
rm(impactFactorsColumnNames2)

# providing names to two columns which don't have them.
# the first one is the "impact category", and the 
# second one was something internal to Peter Canepa's
# process
impactFactorsColumnNames[1] <- "impactCategoryRaw" 
impactFactorsColumnNames[2] <- "peterCcheckVariable" 

# adding the column names to the impact factors
if(
   length(impactFactorsColumnNames)==ncol(impactFactorsRaw)
   ) {
   names(impactFactorsRaw) <- impactFactorsColumnNames
   }
# printing out what we've got so far
str(impactFactorsRaw)
print(impactFactorsRaw)
```
```{r}
# now let's get rid of some of the junk in that file
# of impact factors.
# getting rid of rows with all zero impacts
impactFactorsRawFiltered <- filter(
   impactFactorsRaw,
   impactFactorsRaw[,2]!=0 & impactFactorsRaw[,3]!=0 & impactFactorsRaw[,4]!=0
   )
str(impactFactorsRawFiltered)
```
```{r}
# now let's flip the columns so they are rows.
# we want to create a "tidy" file -- where each
# row is one observation.
impactFactorsRawFlipped <- gather(
   impactFactorsRawFiltered,
   key="material_LCstage_disposition",
   value="impactFactor",
   -impactCategoryRaw
   ) %>%
   # filtering out peter C's private impact category
   filter(material_LCstage_disposition!="peterCcheckVariable")

# printing out what I've got
str(impactFactorsRawFlipped)
```
```{r}
# now I've got these really long fields that need to be parsed into 
# separate fields.

# impactCategoryRaw is actually a concatenation of impactCategory, 
# impactUnits, and corporateSource (for example "TRACI, Global warming 
# potential [MTCO2E]") actually means an impactCategory of 
# "Global warming potential" in impactUnits of "MTCO2E" according to the 
# "TRACI" Corporate Source.

# parsing...
impactFactorsRawFlippedParsed <- mutate(
   impactFactorsRawFlipped,
   corporateSource = str_sub(
      impactCategoryRaw,
      start=0,
      end=str_locate(impactCategoryRaw,",")[,1]-1
      ),
   impactCategory = str_sub(
      impactCategoryRaw,
      start=str_locate(
         impactCategoryRaw,
         ", "
         )[,2]+1,
      end=str_locate(
         impactCategoryRaw,
         " \\["
         )[,1]-1
      ),
   impactCategory=ifelse(
      !is.na(impactCategory),
      impactCategory,
      str_sub(
         impactCategoryRaw,
         start=1,
         end=str_locate(
            impactCategoryRaw,
            "\\["
            )[,1]-2
         )
      ),
   impactUnits= str_sub(
      impactCategoryRaw,
      start=str_locate(
         impactCategoryRaw,
         "\\["
         )[,1]+1,
      end=str_locate(
         impactCategoryRaw,
         "\\]"
         )[,1]-1
      )
   )
str(impactFactorsRawFlippedParsed)

# now similarly field material_LCstage_disposition is a concatenation
# of those fields
# parsing...
impactFactorsRawFlippedParsed2 <- mutate(
   impactFactorsRawFlippedParsed,
   material=str_sub(
      material_LCstage_disposition,
      start=1,
      end=str_locate(material_LCstage_disposition,"_")[,1]-1
      ),
   theRestOfIt=str_sub(
      material_LCstage_disposition,
      start=str_locate(material_LCstage_disposition,"_")[,1]+1,
      end=str_length(material_LCstage_disposition)
      ),
   LCstage=str_sub(
      theRestOfIt,
      start=1,
      end=str_locate(theRestOfIt,"_")[,1]-1
      ),
   disposition=str_sub(
      theRestOfIt,
      start=str_locate(theRestOfIt,"_")[,1]+1,
      end=str_length(theRestOfIt)
      )
   ) %>%
   select(-theRestOfIt)

str(impactFactorsRawFlippedParsed2)

# and let's add a way to identify the set of impact factors.
# this is not strictly necessary right now, but in the long term we'll 
# be doing lots of analyses with various impact factors, and knowing 
# the exact data and version of Gabi's output could 
# be useful.
impactFactorIDinfo <-   
   read_xlsx(
      path=impactFactorsSourceFilespec,
      range="b3:e3",
      col_names=FALSE,
      col_types=c("text","skip","skip","date")
      )
names(impactFactorIDinfo) <- c("impactFactorSource","impactFactorVersionDate")
impactFactorID <- paste(
   impactFactorIDinfo[1,]$impactFactorSource,
   "_",
   as.character(impactFactorIDinfo[1,]$impactFactorVersionDate),
   sep=""
   )
impactFactorsRawFlippedParsed3 <- mutate(
   impactFactorsRawFlippedParsed2,
   impactFactorID=impactFactorID
   )

# and let's get rid of columns I don't want
impactFactorsAll <- select(
   impactFactorsRawFlippedParsed3,
   material,LCstage,disposition,impactCategory,impactUnits,impactFactor,
     corporateSource,impactFactorID
   )
str(impactFactorsAll)

# correcting a typo in the material names
impactFactorsAll <- mutate(
  impactFactorsAll,
  material = ifelse(material == "Woood", "Wood", material)
  ) %>%
  unique() 

# impactFactorsAll is the tidy data frame with the usable factors.

# removing unneeded objects
rm(impactFactorIDinfo,impactFactorsRaw,impactFactorsRawFiltered,
   impactFactorsRawFlipped,impactFactorsRawFlippedParsed,
   impactFactorsRawFlippedParsed2,impactFactorsRawFlippedParsed3,
   impactFactorID,impactFactorsColumnNames,impactFactorsSourceFilespec)

# Because this is such a complicated import process, I am going to write 
# a spreadsheet file to check against Peter Canepa's original.
write.csv(
   impactFactorsAll,
   "intermediate_output/deq_impact_factors_exported_for_checking.csv",
   row.names = FALSE
   )
```

That looked pretty good. I checked some entries at random between my import and Peter C's source and they were all correct.  There was one little problems with the parser that separated the impact category from the corporate source, but given that I'm not using all impact categories anyway that may not make a difference. 

Let's filter that down to the five or six impact categories I want, and shorten the impact factor names to something usable.

```{r}
# winnowing impact factors down to a shorter list
impactFactorsSelected <-
  filter(
    impactFactorsAll,
    impactCategory   == "Blue water consumption" |
      impactCategory == "Eutrophication" |
      impactCategory == "Global Warming Air, incl biogenic carbon, incl LUC, no norm/weight" |
      impactCategory == "Human toxicity, cancer (recommended)" |
      impactCategory == "Primary energy demand from ren. and non ren. resources (net cal. value)" |
      impactCategory == "Smog Air"
      )  %>%
  # making shorter names
  mutate(
    impactCategory   = case_when(
      impactCategory == "Blue water consumption" ~ "Water consumption",
      impactCategory == "Eutrophication" ~ "Eutrophication",
      impactCategory == "Global Warming Air, incl biogenic carbon, incl LUC, no norm/weight" ~ "Global warming",
      impactCategory == "Human toxicity, cancer (recommended)" ~ "Human toxicity",
      impactCategory == "Primary energy demand from ren. and non ren. resources (net cal. value)" ~ "Energy demand",
      impactCategory == "Smog Air" ~ "Smog"
      )
    ) %>%
  # eliminating some technical variables not necessary for the interactive IMFO
  # app
  select(-corporateSource,-impactFactorID)
# the result should looks something like this:
# > print(impactFactorsSelected)
# # A tibble: 198 x 6
#    material LCstage   disposition           impactCategory  impactUnits impactFactor
#    <chr>    <chr>     <chr>                 <chr>           <chr>              <dbl>
#  1 Aluminum endOfLife incinerationNoER      Energy demand   MJ               2.48e+3
#  2 Aluminum endOfLife incinerationNoER      Global warming  kg CO2 eq.       1.49e+2
#  3 Aluminum endOfLife incinerationNoER      Eutrophication  kg N eq.         3.06e-2
#  4 Aluminum endOfLife incinerationNoER      Human toxicity  CTUh             1.51e-7

```

This is good, but it's a little complex for use in most applications of the Waste Impact Calculator.  This set of factors has transport factors separated out for both production and end of life.  We don't need separate production and production transport factors.  Moreover the names for the dispositions are really long.  Finally the LC stages need to be split a little bit, into production, EOL, and EOL transport.  

To do all this I'm going to have to split the impact factor file up and reassemble it after tweaking appropriately.

```{r}
# isolating production impact factors
ifProdJunk1 <- filter(
  impactFactorsSelected,
  LCstage == "production"
  )
# summing those up (combining production & production transport)
ifProdJunk2 <- summarise(
  group_by(ifProdJunk1, material, LCstage, impactCategory, impactUnits),
  impactFactor=sum(impactFactor, na.rm=T)
  ) %>%
  ungroup() %>%
  mutate(disposition="production")
# so ifProdJunk2 has the production impact factors

# isolating end-of-life impact factors
ifEOLJunk1 <- filter(
  impactFactorsSelected,
  LCstage == "endOfLife"
  )

# cleaning up dispositions and LCstages
# splitting the disposition field into first part (the EOL disposition)
# and the second part (the EOL transport)
ifEOLJunk2 <- mutate(
  ifEOLJunk1,
  hello=ifelse(
    regexpr("_",disposition)>0,
    regexpr("_",disposition),
    nchar(disposition)+1
    ),
  disp1=str_sub(disposition, start=1, end=hello-1),
  disp2=str_sub(disposition, start=hello+1, end=nchar(disposition))
  ) %>%
  # now I can make the EOL transport an LC stage
  mutate(
    LCstage=ifelse(
      disp2 == "transport",
      "endOfLifeTransport",
      LCstage
      )
    )
# now I can remove disp2, disposition and the temp variable hello
# and rename disp2 as disposition
ifEOLJunk3 <- select(
  ifEOLJunk2,
  -disp2, -disposition, -hello
  ) %>%
  rename(disposition = disp1)

# now I can recombine the ifProdJunk2 & ifEOLJunk3
ifJunk1 <- bind_rows(
  ifProdJunk2,
  ifEOLJunk3
  )

# now it should look something like this..
# > sample_n(ifJunk1,5)
# # A tibble: 5 x 6
#   material  LCstage          impactCategory impactUnits impactFactor disposition    
#   <chr>     <chr>            <chr>          <chr>              <dbl> <chr>          
# 1 FoodWaste endOfLifeTransp~ Global warming kg CO2 eq.          23.0 incinerationNo~
# 2 FoodWaste production       Smog           kg O3 eq.           85.9 production     
# 3 Aluminum  endOfLife        Smog           kg O3 eq.         -115.  recyclingGener~
# 4 Aluminum  endOfLife        Energy demand  MJ              -30251.  recyclingGener~
# 5 Glass     endOfLifeTransp~ Eutrophication kg N eq.             0   reuse       

```

Currently this list is still pretty long.
I'm going to cut some dispositions as unrealistic.
I'm going to rename some dispositions for clarity.
And I'm going to set the implied mileage of the end-of-life impact factors.

```{r}
# cutting some uncommon dispositions
ifJunk2 <- mutate(
  ifJunk1,
  cutFlag = case_when(
    disposition == "incinerationNoER" ~ TRUE,
    disposition == "recyclingFiberglass" ~ TRUE,
    disposition == "reuse" ~ TRUE
    )
  ) %>%
  filter(is.na(cutFlag)) %>%
  select(-cutFlag) %>%
  # renaming some awkward dispositions
  mutate(
    disposition = case_when(
      disposition == "recyclingGeneric" ~ "recycling",
      disposition == "recyclingAggregate" ~ "useAsAggregate",
      disposition == "recyclingToAggregate" ~ "useAsAggregate",
      disposition == "recyclingToContainer" ~ "recycling",
      disposition == "incinerationER" ~ "combustion",
      TRUE ~ disposition
      )
    ) %>%
  # adding implied mileage for EOL transport impact factors
  mutate(
    impliedMiles = case_when(
      LCstage == "endOfLifeTransport" & disposition == "landfilling" ~ 180,
      LCstage == "endOfLifeTransport" & disposition == "recycling" ~ 180,
      LCstage == "endOfLifeTransport" & disposition == "composting" ~ 180,
      LCstage == "endOfLifeTransport" & disposition == "useAsAggregate" ~ 20,
      LCstage == "endOfLifeTransport" & disposition == "anaerobicDigestion" ~ 180,
      LCstage == "endOfLifeTransport" & disposition == "combustion" ~ 180,
      TRUE ~ 180
      )
    ) %>%
  # reordering the variables
  select(material, LCstage, disposition, impactCategory,
         impactUnits, impactFactor, impliedMiles)

# saving that as the dedicated impact factor file
impactFactorsIMFOapp <- ifJunk2

# sorting it
impactFactorsIMFOapp <- arrange(
  impactFactorsIMFOapp, material, impactCategory, LCstage, disposition
  )
```

however, peter canepa says not to use a few of those, because he's still working on them.

```{r}
impactFactorsIMFOapp <-
  filter(impactFactorsIMFOapp, material != "Wood" & material != "Electronics")
```

```{r}
# let's rename it
impact_factors_deq <- impactFactorsIMFOapp
```


If it all looks good, I can delete the temporary objects.
```{r}
# deleting work objects
rm(ifEOLJunk1, ifEOLJunk2, ifEOLJunk3, ifJunk1, ifJunk2, ifProdJunk1,
   ifProdJunk2, impactFactorsAll, impactFactorsSelected,
   impactFactorsIMFOapp)
```

So, as a test, I checked the "Glass" impact factors in impact_factors_deq against Peter C's original spreadsheet and everything checked out.  The important thing to remember is that the end-of-life transport factors include an implied mileage... i.e. at this point they are NOT in per-mile terms.

```{r}
# load in the waste data and split it into the old object names
observedWaste <- readRDS("intermediate_output/observedWaste.RData")
disposal_tons_by_mrs_material <-
  observedWaste %>% 
  filter(source=="disposal_tons_by_mrs_material") %>%
  select(-source, -swims_disposition_code)
recovery_tons_by_mrs_material <-
  observedWaste %>%
  filter(source=="recovery_tons_by_mrs_material") %>%
  select(-source)
rm(observedWaste)
```


----begin insertion of old code---


# Status at this point in the analysis.

I currently have two main data frames expressing the contents of solid waste -- disposal_tons_by_mrs_material, and recovery_tons_by_mrs_material.  I need to link them up, so they're in a single file, and then also make sure the materials and dispositions in the solid waste file have equivalents in terms of the impact factors I'm going to use.... without losing any tons.

Let's just list the structures of those two solid waste files, list the material names, and then get the impact factors.

## structure of the current SW files

```{r}
str(disposal_tons_by_mrs_material)
str(recovery_tons_by_mrs_material)
```

## list of all the material names in the solid waste data
```{r}
all_sw_data_temp <-
  bind_rows(disposal_tons_by_mrs_material, recovery_tons_by_mrs_material)
table(all_sw_data_temp$material, useNA="always")
sum(table(all_sw_data_temp$material, useNA="always"))
all_sw_data_materials_temp <- as.data.frame(unique(all_sw_data_temp$material))
print(all_sw_data_materials_temp)
rm(all_sw_data_temp, all_sw_data_materials_temp)
```

It looks like a few categories have been added... things like "Animal Waste/grease" weren't recorded in recovery but could be recovered?

# Bringing in the impact factors.

In this work I want to use DEQ's own impact factors, which I already imported. After that's done I need to confirm I can set an impact factor for every available combination of material and disposition.


## Associating the recovery materials and disposition codes with impact factors.

Now I'm going to tie the recovered materials and dispositions, which are in MRS terms, to material and disposition names and impact factors from the DEQ's set of impact factors.  Along the way I will correct some unlikely entries in the recovery data collection, such as tons of aluminum being composted.

Both the name and disposition translations and the corrections will come from a crosswalk file in the source_data directory, "mrs_x_deq_xwalk.xlsx".

```{r}
# code to start making the crosswalk file (optional)
junk1 <- 
  recovery_tons_by_mrs_material %>%
  select(material, swims_disposition_code) %>%
  unique()
junk2 <-
  readRDS("intermediate_output/swims_disposition_types.RData")
junk3 <-
  full_join(junk1, junk2, by="swims_disposition_code") %>%
  filter(!is.na(material)) %>%
  rename(swims_disp=swims_disposition_short_desc) %>%
  select(material, swims_disp) %>%
  arrange(material, swims_disp)
write.csv(
  junk3,
  "intermediate_output/observed_recovery_dispositions.csv",
  row.names = FALSE
)
# let's get a similar list of combinations in the deq impact factors
junk4 <-
  impact_factors_deq %>% 
  filter(LCstage=="endOfLife") %>%
  select(material, disposition) %>%
  unique()
write.csv(
  junk4,
  "intermediate_output/deq_eol_dispositions.csv",
  row.names = FALSE
)
rm(junk1, junk2, junk3, junk4)

```

```{r}
getwd()
```


```{r}
# importing the crosswalk equivalencies for recovery and disposal...
mrs_deq_xwalk <- 
  read_excel(
    path = "../../source_data/mrs_x_deq_xwalk.xlsx",
    range = "a1:d100"
  ) %>%
  filter(!is.na(material) & !is.na(disposition))
```


```{r}
# linking recovery data to warm names and dispositions..
junk2 <-
  readRDS("intermediate_output/swims_disposition_types.RData") %>%
  select(swims_disposition_code, swims_disposition_short_desc) %>%
  rename(swims_disp=swims_disposition_short_desc)

recovery_tons_by_mrs_material2 <-
  left_join(
    recovery_tons_by_mrs_material,
    junk2,
    by="swims_disposition_code"
  ) %>%
  select(-swims_disposition_code) %>%
  rename(swims_material=material)

recovery_tons_temp_1 <-
  left_join(
    recovery_tons_by_mrs_material2,
    mrs_deq_xwalk,
    by = c("swims_material", "swims_disp")
  ) %>%
  filter(!is.na(material) & !is.na(disposition)) %>%
  select(-swims_material, -swims_disp)
rm(junk2, recovery_tons_by_mrs_material, recovery_tons_by_mrs_material2)
```  

Ok, at this point anything in recovery_tons_temp_1 is a recovered material that I have an impact factor for.  That doesn't mean it's the whole waste stream.

I'm going to have to figure out which portion of the waste stream later.

Now I need to do a similar process with disposal entries.  Those need to be spread across landfilling and combustion. 

## spreading disposal tons over landfilling and combustion

For the most part, disposal in Oregon is done via landfilling.  However, some waste does go to a single incinerator near Salem.  The incinerator takes a lot of Marion County's waste.   So I need to spread each wasteshed's disposal over two dispositions: landfilling and combustion.  

To do this I need to dig into detailed disposal data records and pull out the shipments from individual wastesheds to individual disposal facilities.  Then I can calculate the proportion of disposal from each wasteshed that was incineration.

```{r}
# some constants I need
year_of_interest <- c(2018)
swims_access_filespec <- 
  "//deqhq1/swrshare/!ADMINISTRATIVE-(ADM)/Databases/SWIMS/NewSWIMS/SWIMSprod.mdb"
swims_wastesheds <- 
  readRDS("intermediate_output/swims_wastesheds.RData")

# starting by opening a connection to the access database
swims_access_edition <- odbcConnectAccess(swims_access_filespec)

# seeing if I've got a connection at all
# myList <- sqlTables(channel = swims_access_edition)

# getting all the disposal data, unfiltered
disposal_detail_all <- sqlFetch(
  channel = swims_access_edition,
  sqtable = "martinDisposalDataAsOf20191125",
  stringsAsFactors = FALSE
)

# closing the database connection and cleaning up
odbcClose(swims_access_edition)
rm(swims_access_edition, swims_access_filespec)
```

I need to wittle it down -- keeping only relevant fields and filtering out non-"counting" waste and out of state stuff.
```{r}
disposal_detail <- 
  # keeping only relevant fields
  select(
    disposal_detail_all,
    CID,
    Year,
    Matl,
    Tons,
    WS_Collection,
    oos
  ) %>%
  filter(
    Year == year_of_interest &  # isolating the year of interest
      (Matl == "SW" |           # keeping only materials in counting waste
       Matl == "CD" | 
       Matl == "TIR" | 
       Matl == "GY" | 
       Matl == "AWG") &
      oos == 0                  # picking only waste collected in-state
  ) %>%
  # using the incinerator's CID code to separate incineration from landfilling
  mutate(
    disposal_type = 
      ifelse(
        CID == 1077,
        "combustion",
        "landfilling"
      )
  )
rm(disposal_detail_all)         # getting rid of that big object
```


Now I need to sum up incinerator vs non-incinerator tons for disposal for each wasteshed.   According to Spendelow, that's equivalent to isolating tons from CID code 1077 or not (as filtered above).

```{r}
# figuring total tons of combustion and landfilling per wasteshed
disposal_by_wasteshed_and_type <-
  summarise(
    group_by(disposal_detail, Year, WS_Collection, disposal_type),
    Tons = sum(Tons, na.rm = T)
  ) %>% 
  ungroup()
# converting those to ratios
disposal_by_wasteshed_and_type_wide <-
  spread(
    disposal_by_wasteshed_and_type,
    key = disposal_type,
    value = Tons
  ) %>%
  mutate(
    landfill_ratio = 
      ifelse(
        is.na(combustion),
        1,
        landfilling/(combustion+landfilling)
      ),
    combustion_ratio = 1-landfill_ratio
  )
# flipping that back to a long skinny data frame
disposal_by_wasteshed_and_type_skinny <-
  gather(
    select(
      disposal_by_wasteshed_and_type_wide,
      -combustion, -landfilling
    ),
    key = disposal_type,
    value = proportion_of_tons,
    landfill_ratio:combustion_ratio
    ) %>%
  arrange(Year, WS_Collection, disposal_type)
```

Ok, that object disposal_by_wasteshed_and_type_skinny has the ratios I need.

Let's clean up the workspace a bit.

```{r}
# removing obsolete objects
rm(disposal_by_wasteshed_and_type, disposal_by_wasteshed_and_type_wide,
   disposal_detail)
```

Now, to apply those ratios to the materials in disposal.
First I'll fix names.

```{r}
# fixing wasteshed codes and field names so the match 
# will go smoother
disposal_types_temp1 <- 
  left_join(
    rename(
      disposal_by_wasteshed_and_type_skinny,
      year = Year,
      wasteshed_code = WS_Collection,
      disposition = disposal_type
    ),
    swims_wastesheds,
    by = "wasteshed_code"
    ) %>%
  mutate(
    # wasteshed = 
    #   ifelse(
    #     wasteshed=="Milton Freewater",
    #     "Milton-Freewater",
    #     wasteshed
    # ),
    disposition = case_when(
      disposition == "combustion_ratio"  ~ "combustion",
      disposition == "landfill_ratio" ~ "landfilling"
    )
  ) %>%
  select(year, wasteshed, disposition, proportion_of_tons)
```

Now I'll apply all the proportions to the existing disposed materials.  This will double the number of lines in the disposal file, but shouldn't change the total number of tons.

```{r}
disposal_tons_by_mrs_material_and_disposition_all <- 
  full_join(
    disposal_tons_by_mrs_material,
    disposal_types_temp1,
    by = c("year", "wasteshed")
    ) %>%
  rename(total_tons = tons) %>%
  mutate(
    tons = proportion_of_tons*total_tons
  ) %>%
  select(-total_tons, -proportion_of_tons) %>%
  rename(swims_material=material, swims_disp=disposition)
```

Next I'm going to edit it, to restrict it to materials and dispositions for which we have impact factors.

```{r}
disposal_tons_by_mrs_material_and_disposition <-
  left_join(
    disposal_tons_by_mrs_material_and_disposition_all,
    mrs_deq_xwalk,
    by=c("swims_material", "swims_disp")
  ) %>%
  select(-swims_material, -swims_disp) %>%
  filter(!is.na(material) & !is.na(disposition))
```

Ok, now I've got disposal tons with detailed dispositions by wasteshed, in object disposal_tons_by_mrs_material_and_disposition. 

Might be a good idea to save the proportions of disposal by wasteshed for future sessions.
```{r}
# saving proportions of disposal per wasteshed.
saveRDS(
  disposal_types_temp1,
  file = "intermediate_output/disposal_disposition_proportions_by_wasteshed.RData"
)
```

Let's clean up the workspace.

```{r}
rm(disposal_by_wasteshed_and_type_skinny, disposal_tons_by_mrs_material,
   disposal_types_temp1, disposal_tons_by_mrs_material_and_disposition_all)
```

## A bit of perspective

So now I have two files with end-of-life information in them which should have DEQ impact factors.

If I add the disposal_tons in disposal_tons_by_mrs_material_and_disposition to the recovery information in recovery_tons_temp1, I will have a complete picture of the solid waste stream IN TERMS OF THE MATERIALS FOR WHICH I POSSESS IMPACT FACTORS. 

Sometime (not in the current session) I need to quantify how much is being left behind.  And decide how I'm going to treat that stuff... by ignoring it, or using estimated impact factors?

But anyway, later.

## Creating the baseline mass profile, with a zero file.

I would like the baseline mass profile to include entries for all the possible dispositions as well as all the utilized dispositions.  So let's do that.

```{r}
bmp1 <- 
  bind_rows(
    disposal_tons_by_mrs_material_and_disposition %>%
      mutate(umbDisp="disposal"),
    recovery_tons_temp_1 %>% mutate(umbDisp="recovery")
  )
bmp_material_list <-
  bmp1 %>% select(material) %>% unique()
bmp_possible_dispositions <-
  right_join(
    impact_factors_deq %>% 
      filter(LCstage=="endOfLife") %>%
      select(material, disposition) %>%
      unique(),
    bmp_material_list,
    by="material"
  )
bmp_ws_list <- 
  bmp1 %>% select(year,wasteshed) %>% unique()
bmp_possible_ws_material_disposition_combos <-
  full_join(
    bmp_ws_list %>% mutate(dummy=1),
    bmp_possible_dispositions %>% mutate(dummy=1),
    by="dummy"
  ) %>%
  select(-dummy)
bmp2 <- 
  full_join(
    bmp_possible_ws_material_disposition_combos,
    bmp1,
    by=c("year", "wasteshed", "material", "disposition")
  ) %>%
  mutate(
    # fill in missing values
    tons=ifelse(is.na(tons),0,tons),
    umbDisp=ifelse(
      is.na(umbDisp),
      case_when(
        disposition=="recycling" ~ "recovery",
        disposition=="anaerobicDigestion" ~ "recovery",
        disposition=="recyclingPozzolan" ~ "recovery",
        disposition=="recyclingToFiberglass" ~ "recovery",
        disposition=="reuseContainer" ~ "recovery",
        disposition=="useAsAggregate" ~ "recovery",
        disposition=="composting" ~ "recovery"
      ),
      umbDisp
    )
  )

```
So bmp2 is the baseline mass profile.  Let me save it properly,  save the mass profile and the impact factors to external files, and double check that every entry has impact factors.

```{r}
# saving
baseline_mass_profile <- bmp2
saveRDS(
  baseline_mass_profile, "intermediate_output/baseline_mass_profile.RData"
)
write.csv(
  baseline_mass_profile,
  "intermediate_output/baseline_mass_profile.csv",
  row.names = FALSE
)
saveRDS(
  impact_factors_deq, "intermediate_output/impact_factors.RData"
)
write.csv(
  impact_factors_deq,
  "intermediate_output/impact_factors.csv",
  row.names=FALSE
)
# checking for synchrony
bmp_test<- left_join(
  baseline_mass_profile,
  impact_factors_deq,
  by=c("material", "disposition")
) %>% filter(is.na(impactFactor))
```

if bmp_test has 0 records, that means all the masses have impact factors.

however, we don't know if all the masses are included.  That's a place I will need to improve this code.

```{r}
# cleaning the space
rm(list=ls())
```
